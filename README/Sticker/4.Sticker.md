- 먼저 해당 챕터의 내용을 하기전에 폴더를 몇가지 만들도록 하겠습니다.

- `Django` 프로젝트 폴더에 있는 `Static`에 들어가셔서 `camera_sticker`라는 폴더를 만들어주도록 하겠습니다.

- 그리고 그안에 AI가 작동하는지 확인하기 위한 이미지를 담는 `images`와 `LandMark`파일을 담을 `models`를 만들어주도록 하겠습니다.

```console
static
└───camera_sticker
   ├───images
   └───models
```

- 마지막으로 테스트로 사용될 `image.png` 와 스티커가 될 `king.png`를 넣어주면 됩니다 .

- `image.png` : 원하는 사진 아무거나 지참 하시면 됩니다 .

- `king.png` : https://drive.google.com/file/d/1knZtRmrsXVqYutibA9O06QVhFXb4oWl4/view?usp=sharing

```console
static
└───camera_sticker
   ├───images
   │    ├── image.png
   │    └── king.png
   └───models
```

- 그럼 스티커를 붙여주는 코드를 어디서 관리하는지 알려드리겠습니다.

- 프로젝트 폴더에 `utils` 라는 폴더를 만들고 그안에 `sticker.py`라는 파일안에 코드를 작성하면됩니다.

- 하지만 코드 작성 이전에 우리가 필요한 `라이브러리`들을 설치하고 가도록 하겠습니다.

```py
pip install opencv-python
pip install matplotlib
pip install cmake
pip install dlib
```

```py
import os
import cv2
import matplotlib.pyplot as plt
import numpy as np
import dlib
print("🛸")
```

- 결과물이 `🛸`이 나오는것을 볼수 있습니다.

```py
my_image_path = 'C:/Users/kimud/바탕 화면/test2/KUD/firstproejct/static/camera_sticker/images/image.png'
my_image_path_encode= np.fromfile(my_image_path, np.uint8)
img_bgr = cv2.imdecode(my_image_path_encode,cv2.IMREAD_UNCHANGED)    # OpenCV로 이미지를 불러옵니다
img_show = img_bgr.copy()      # 출력용 이미지를 따로 보관합니다

plt.imshow(img_bgr)
plt.show()
```

```py
  # Section 3
    # SVG detector를 선언합니다
    detector_hog = dlib.get_frontal_face_detector()

    # Bounding box 추출
    img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)
    dlib_rects = detector_hog(img_rgb, 1)   # (image, num of image pyramid)

    for dlib_rect in dlib_rects:
        l = dlib_rect.left()
        t = dlib_rect.top()
        r = dlib_rect.right()
        b = dlib_rect.bottom()

        cv2.rectangle(img_show, (l,t), (r,b), (0,255,0), 2, lineType=cv2.LINE_AA)

    img_show_rgb =  cv2.cvtColor(img_show, cv2.COLOR_BGR2RGB)
    plt.imshow(img_show_rgb)
    plt.show()

```

- 자 이제 이미지 박스에 초록색 네모가 생기게 될거에요( 다들 알고 계시죠? ㅎㅎ )

- 이제 `Dlib`을 통해 `LandMark`를 세워보도록 하겠습니다.

- 먼저 아래 `URL`을 통해 `LandMark`파일을 설치하시고, 압축을 풀어 `shape_predictor_68_face_landmarks`파일을 꺼내보도록 하겠습니다.

```
    http://dlib.net/files/shape_predictor_68_face_landmarks.dat.bz2
```

- `shape_predictor_68_face_landmarks.dat`파일을 아래와 같이 넣어주도록 하겠습니다.

```console
static
└───camera_sticker
   ├───images
   │   ├── image.png
   │   └── king.png
   └───models
       └───shape_predictor_68_face_landmarks.dat
```

- 그럼 `exploration`에 따라 랜드마크를 찍어주도록 하겠습니다.

- 이때 `model_path`현재 작성자의 컴퓨터로 작성 되어있습니다. (이부분은 본인 컴퓨터에 맞추어 작성)

> 또한 경로에 한글이 있으면 안되더라....

```py
    # Section 4
    # LandMark 찍기
    model_path = 'C:/Users/kimud/KUD/firstproejct/static/camera_sticker/models/shape_predictor_68_face_landmarks.dat'
    landmark_predictor = dlib.shape_predictor(model_path)

    list_landmarks = []

    # 얼굴 영역 박스 마다 face landmark를 찾아냅니다
    for dlib_rect in dlib_rects:
        points = landmark_predictor(img_rgb, dlib_rect)
        # face landmark 좌표를 저장해둡니다
        list_points = list(map(lambda p: (p.x, p.y), points.parts()))
        list_landmarks.append(list_points)
```

- 이제 `LandMark`가 제대로 찍혔는지 확인 해보도록 하겠습니다.

```py
  # Section 5
    # LandMark 출력

    for landmark in list_landmarks:
        for point in landmark:
            cv2.circle(img_show, point, 2, (0, 255, 255), -1)

    img_show_rgb = cv2.cvtColor(img_show, cv2.COLOR_BGR2RGB)
    plt.imshow(img_show_rgb)
    plt.show()
```

- `LandMark`가 찍히는게 확인이 되었으면 이제 스티커를 붙이고 정리 해보도록 하겠습니다.

- 스티커 사진을 `path`를 지정할때 역시 본인의 `path`를 지정해야합니다.

```py
 # Section 6
    # 스티커 위치 구하기

    for dlib_rect, landmark in zip(dlib_rects, list_landmarks):
        x = landmark[30][0]
        y = landmark[30][1] - dlib_rect.height()//2
        w = h = dlib_rect.width()

    # 스티커 사이즈 조절
    sticker_path = 'C:/Users/kimud/KUD/firstproejct/static/camera_sticker/images/king.png'
    img_sticker = cv2.imread(sticker_path) # 스티커 이미지를 불러옵니다
    img_sticker = cv2.resize(img_sticker, (w,h))

    # 스티커위치 조정
    refined_x = x - w // 2
    refined_y = y - h

    # 스티커 위치 넘어가면 잘리게
    if refined_x < 0:
        img_sticker = img_sticker[:, -refined_x:]
        refined_x = 0
    if refined_y < 0:
        img_sticker = img_sticker[-refined_y:, :]
        refined_y = 0

    # 사진에 적용후 출력
    sticker_area = img_bgr[refined_y:refined_y +img_sticker.shape[0], refined_x:refined_x+img_sticker.shape[1]]
    img_bgr[refined_y:refined_y +img_sticker.shape[0], refined_x:refined_x+img_sticker.shape[1]] = \
        np.where(img_sticker==0,sticker_area,img_sticker).astype(np.uint8)

    plt.imshow(cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB))
    plt.show()
```

- 그럼 `python sticker.py`를 실행시키면 사진에 스티커가 붙여져서 나오는걸 확인 할수있습니다.

- 이제 장고에서 이미지를 받을수 있도록 사이트를 두개 만들도록 하겠습니다.

- 첫번째 사이트는 `input`을 통해 이미지를 받는역할을 하고 두번째 사이트는 `ouput`을 화면에 보여주는 역할을 합니다.

- 그럼 먼저 `html` 파일을 두개를 만들도록 하겠습니다.

- `stickerResult.html` : `image`를 보여주는 페이지입니다.

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sticker AI view</title>
  </head>
  <body>
    <div>
      <img src="{{ image }}" style="width: 40vw" alt="convertImage" />
    </div>
  </body>
</html>
```

- `sticker.html`: `input`태그를 통해 이미지를 받게 되는 페이지입니다.

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sticker AI</title>
  </head>
  <body>
    <div class="container">
      <!-- form action을 통해 이미지가 전송이 되었을때 처리할 내용물이 전달이 되면 페이지 이동-->
      <form
        method="POST"
        action="{% url 'stickerResult.html' %}"
        enctype="multipart/form-data"
      >
        {% csrf_token %}
        <input type="file" name="image" /><br />
        <input type="submit" value="테스트 해보기 " />
      </form>
    </div>
  </body>
</html>
```

- 이제 `html`을 보여주는걸 담당하는 `views.py`에서 설정을 해주겠습니다.

- 일단 `sticker`는 단순하게 페이지만 보여주면 되기 때문에 아래와 같이 코드를 치면됩니다.

```py
# views.py
def sticker(req):
    return render(req,'Landing/sticker.html')

```

- `stickerResult`는 이미지에서 받은 값을 가공해서 다시 올려하기 때문에 여기서 차이가 있을수 있습니다.

- `POST`통신과 `GET` 통신에 대해선느 앞서 `Figma`를 통해 설명을 드렸습니다.

- 이미지를 보낼수 있는건 `POST` 통신이기 때문에 해당 통신이 왔을때 인공지능을 돌려 처리하도록 하겠습니다.

```py
# views.py
def stickerResult(request):
    if request.method == 'POST': # 통신이 post일때
        try:
            img = request.FILES["image"].read() # 통신에서 iamge를 읽어 드리도록 한다.
            convertImg = 인공지능 코드  # 인공지능 코드를 추가해야한다
            return render(request, 'Landing/stickerResult.html', {'image':convertImg}) # stickerResult.html을 보여줄때 가공한 image파일도 같이 넘긴다
        except:
            return   HttpResponse("보여줄 이미지가 없습니다!") # image 파일이 없으면 처리
    else:
        return   HttpResponse("보여줄 이미지가 없습니다!") # post 통신이 아니면 자료를 보낼수 없어서 예외 처리
```

- 마지막으로 이렇게 `views`에서 열심히 작성한 함수를 `urls.py`에서 연결시켜 보도록 하겠습니다.

```py
urlpatterns = [
    path('admin/', admin.site.urls),
    path('',Landing.views.index,name="index"),
    path('study',Landing.views.study,name="study"),
    path('sticker',Landing.views.sticker,name="sticker"), #스티커 입력하는 페이지
    path('stickerResult',Landing.views.stickerResult,name="stickerResult") #스티커 보여주는 페이지
]

```

- 이제 다시 인공지능 코드를 다듬을때가 왔습니다.

- 먼저 이제는 파이썬을 통해 이미지를 보여줄 필요가 없기 때문에 `plt.imshow`, `plt.show` 함수를 날리도록 하겠습니다.

- 그리고 `opencv`를 통해 가공한 이미지를 읽을수 있도록 변환해야 하기 때문에 몇가지 코드를 추가하도록 하겠습니다.

```py
import os
import cv2
import matplotlib.pyplot as plt
import numpy as np
import dlib
# img 태그에서 읽을수 있도록 가공하는 라이브러리 추가
import base64

# 함수를 통해 불러와 실행 시킬수 있도록 함수화
def stickerGen(img):
    img_bgr = cv2.imdecode(np.fromstring(img, np.uint8), cv2.IMREAD_UNCHANGED)
    img_show = img_bgr.copy()

    detector_hog = dlib.get_frontal_face_detector()

    img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)
    dlib_rects = detector_hog(img_rgb, 1)

    for dlib_rect in dlib_rects:
        l = dlib_rect.left()
        t = dlib_rect.top()
        r = dlib_rect.right()
        b = dlib_rect.bottom()

        cv2.rectangle(img_show, (l,t), (r,b), (0,255,0), 2, lineType=cv2.LINE_AA)

    img_show_rgb =  cv2.cvtColor(img_show, cv2.COLOR_BGR2RGB)

    model_path = 'C:/Users/kimud/KUD/firstproejct/static/camera_sticker/models/shape_predictor_68_face_landmarks.dat'
    landmark_predictor = dlib.shape_predictor(model_path)

    list_landmarks = []

    for dlib_rect in dlib_rects:
        points = landmark_predictor(img_rgb, dlib_rect)
        list_points = list(map(lambda p: (p.x, p.y), points.parts()))
        list_landmarks.append(list_points)


    for landmark in list_landmarks:
        for point in landmark:
            cv2.circle(img_show, point, 2, (0, 255, 255), -1)

    img_show_rgb = cv2.cvtColor(img_show, cv2.COLOR_BGR2RGB)


    for dlib_rect, landmark in zip(dlib_rects, list_landmarks):
        x = landmark[30][0]
        y = landmark[30][1] - dlib_rect.height()//2
        w = h = dlib_rect.width()

    sticker_path = 'C:/Users/kimud/KUD/firstproejct/static/camera_sticker/images/king.png'
    img_sticker = cv2.imread(sticker_path) # 스티커 이미지를 불러옵니다
    img_sticker = cv2.resize(img_sticker, (w,h))

    refined_x = x - w // 2
    refined_y = y - h

    if refined_x < 0:
        img_sticker = img_sticker[:, -refined_x:]
        refined_x = 0
    if refined_y < 0:
        img_sticker = img_sticker[-refined_y:, :]
        refined_y = 0

    sticker_area = img_bgr[refined_y:refined_y +img_sticker.shape[0], refined_x:refined_x+img_sticker.shape[1]]
    img_bgr[refined_y:refined_y +img_sticker.shape[0], refined_x:refined_x+img_sticker.shape[1]] = \
        np.where(img_sticker==0,sticker_area,img_sticker).astype(np.uint8)


    # 이미지를 img태그에서 넣어 인식할수 있도록 코드를 변경
    img_bgr_buffer= cv2.imencode('.jpg', img_bgr)[1]
    # img 태그에 src에서 자료를 읽기 위해서는 base64 기반의 utf-8 인코딩이 필요
    result = base64.b64encode(img_bgr_buffer).decode("utf-8")
    return result
```

- 해당 코드를 위와 같이 수정하시고 `views.py`에서 인공지능을 보여주는 코드 역시 아래와 같이 바꿔주도록 합시다.

```py
from django.shortcuts import render
from django.core.files.storage import default_storage
# httpResponse를 위해 임포트
from django.http import HttpResponse
# 인공지능을 관리하는 코드 임포트
from utils.sticker import stickerGen


# Create your views here.
def index(req):
    return render(req,'Landing/index.html')

def sticker(req):
    return render(req,'Landing/sticker.html')

def study(req):
    return render(req,'Landing/study.html')


def stickerResult(request):
    if request.method == 'POST': # 통신이 post일때
        try:
            img = request.FILES["image"].read() # 통신에서 iamge를 읽도록 한다.
            convertImg = "data:image/jpg;base64, "+str(stickerGen(img)) # Html img 태그에서 출력할수 있도록 base64 타입으로 변환
            return render(request, 'Landing/stickerResult.html', {'image':convertImg}) # stickerResult.html을 보여줄때 가공한 image파일도 같이 넘긴다
        except:
            return   HttpResponse("보여줄 이미지가 없습니다!") # image 파일이 없으면 처리
    else:
        return   HttpResponse("보여줄 이미지가 없습니다!") # post 통신이 아니면 자료를 보낼수 없어서 예외 처리
```
